---
title: "rank binned genome"
author: "Amalia"
date: "2023-10-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#rank the binned genomes

Load packages
```{r}
#library(GenomicRanges)
library(tidyverse)
#library (purrr)
#library(plyranges)
#library(rlist)
library(ggvenn)
library(UpSetR)
```

##I ll only keep the samples with enough coverage
```{r}
sample_names<-c("GSM4594635","GSM1382253","GSM2533056","GSM4837324","GSM1382256","GSM1545748","GSM748786","GSM748787")
addback<-c("DNMT3A2", "DNMT3A2", "DNMT3A1", "DNMT3B1","DNMT3B1","DNMT3B1","WT","WT") #I have to use these as names as well
```
#first I will NOT keep only the bins that are common in all the samples, but afterwards I will.
I will rank separately the 3A, 3B, and WT.
In 3a samples, rank 1 will be the bins with maximum preference for pyrimidine in their ratio
In 3b samples, rank 1 will be the bins with maximum preference for purime in their ratio
WT samples will be ranked twice, so that their top bins can serve as a "backround" for both a and b, so for comparison with A the rank 1 will be the bins with maximum preference for pyrimidine in their ratio and vice versa.

#here for top 1%
```{r}
#first for 3a
#this is how to get the top 1% (must do same for bottom and for 10% similarly)
for(i in 1:3){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most negative will be rank1 
  #negatives have a pyrimidine preference 
  t<-round(nrow(c)*0.01) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/top1%/", sample_names[i], ".rds"))#save the table created for this sample
}

#same for 3B
for(i in 4:6){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most positivw will be rank1 
  #negatives have a purine preference 
  t<-round(nrow(c)*0.01) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/top1%/", sample_names[i], ".rds"))#save the table created for this sample
}

#now same for WT, once treated as 3A and once as 3B
#as 3a
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most negative will be rank1 
  #negatives have a pyrimidine preference 
  t<-round(nrow(c)*0.01) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/top1%/", sample_names[i], "_as3A.rds"))#save the table created for this sample
}

#same for as 3B
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most positivw will be rank1 
  #negatives have a purine preference 
  t<-round(nrow(c)*0.01) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  #assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/top1%/", sample_names[i], "_as3B.rds"))#save the table created for this sample
}

readRDS("../data/processed/bins/CpGs/1kb/top1%/GSM748787_as3B.rds")

readRDS("../data/processed/bins/CpGs/1kb/top1%/GSM748787_as3A.rds")
```
#do the rest!!

#here for top 10%

```{r}
#first for 3a
#this is how to get the top 10% (must do same for bottom )
for(i in 1:3){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most negative will be rank1 
  #negatives have a pyrimidine preference 
  t<-round(nrow(c)*0.1) # find n for top 10 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 10%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/top10%/", sample_names[i], ".rds"))#save the table created for this sample
}

#same for 3B
for(i in 4:6){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most positivw will be rank1 
  #negatives have a purine preference 
  t<-round(nrow(c)*0.1) # find n for top 10 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 10%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/top10%/", sample_names[i], ".rds"))#save the table created for this sample
}

#now same for WT, once treated as 3A and once as 3B
#as 3a
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most negative will be rank1 
  #negatives have a pyrimidine preference 
  t<-round(nrow(c)*0.1) # find n for top 10 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/top10%/", sample_names[i], "_as3A.rds"))#save the table created for this sample
}

#same for as 3B
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most positivw will be rank1 
  #negatives have a purine preference 
  t<-round(nrow(c)*0.1) # find n for top 10 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  #assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/top10%/", sample_names[i], "_as3B.rds"))#save the table created for this sample
}
```

#now for bottom ranked (least preference, or better preference for the opposite)
for bottom 1%
```{r}
#first for 3a
#this is how to get the bottom 1% (must do same for 10% similarly)
for(i in 1:3){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference so we put 
  #most positive will be rank1 
  #negatives have a pyrimidine preference 
  #positives purine preference
  t<-round(nrow(c)*0.01) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/bottom1%/", sample_names[i], ".rds"))#save the table created for this sample
}

#same for 3B
for(i in 4:6){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference 
  #most megative will be rank1 
  #negatives have a purine preference 
  #positives purine pref
  t<-round(nrow(c)*0.01) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/bottom1%/", sample_names[i], ".rds"))#save the table created for this sample
}

#now same for WT, once treated as 3A and once as 3B
#as 3a
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference
  #most negative will be rank1 
  #negatives have a pyrimidine preference 
  t<-round(nrow(c)*0.01) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/bottom1%/", sample_names[i], "_as3A.rds"))#save the table created for this sample
}

#same for as 3B
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference
  #most positivw will be rank1 
  #negatives have a purine preference 
  t<-round(nrow(c)*0.01) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  #assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/bottom1%/", sample_names[i], "_as3B.rds"))#save the table created for this sample
}
```
for bottom 10%
```{r}
#first for 3a
#this is how to get the bottom 1% (must do same for 10% similarly)
for(i in 1:3){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference so we put 
  #most positive will be rank1 
  #negatives have a pyrimidine preference 
  #positives purine preference
  t<-round(nrow(c)*0.1) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/bottom10%/", sample_names[i], ".rds"))#save the table created for this sample
}

#same for 3B
for(i in 4:6){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference 
  #most megative will be rank1 
  #negatives have a purine preference 
  #positives purine pref
  t<-round(nrow(c)*0.1) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/bottom10%/", sample_names[i], ".rds"))#save the table created for this sample
}

#now same for WT, once treated as 3A and once as 3B
#as 3a
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference
  #most negative will be rank1 
  #negatives have a pyrimidine preference 
  t<-round(nrow(c)*0.1) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/bottom10%/", sample_names[i], "_as3A.rds"))#save the table created for this sample
}

#same for as 3B
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference
  #most positivw will be rank1 
  #negatives have a purine preference 
  t<-round(nrow(c)*0.1) # find n for top 10 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 10%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  #assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins/CpGs/1kb/bottom10%/", sample_names[i], "_as3B.rds"))#save the table created for this sample
}
```

RANK the stranded binned genome


#here for top 10%
```{r}
sample_names<-c("GSM4594635","GSM1382253","GSM2533056","GSM4837324","GSM1382256","GSM1545748","GSM748786","GSM748787")
addback<-c("DNMT3A2", "DNMT3A2", "DNMT3A1", "DNMT3B1","DNMT3B1","DNMT3B1","WT","WT") #I have to use these as names as well
#first for 3a
#this is how to get the top 1% (must do same for bottom and for 10% similarly)
for(i in 1:3){
  c<-readRDS(file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most negative will be rank1 
  #negatives have a pyrimidine preference 
  t<-round(nrow(c)*0.01) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/top1%/", sample_names[i], ".rds"))#save the table created for this sample
}

#same for 3B
for(i in 4:6){
  c<-readRDS(file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most positivw will be rank1 
  #negatives have a purine preference 
  t<-round(nrow(c)*0.01) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 10%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/top1%/", sample_names[i], ".rds"))#save the table created for this sample
}

#now same for WT, once treated as 3A and once as 3B
#as 3a
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most negative will be rank1 
  #negatives have a pyrimidine preference 
  t<-round(nrow(c)*0.1) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/top10%/", sample_names[i], "_as3A.rds"))#save the table created for this sample
}

#same for as 3B
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  #most positivw will be rank1 
  #negatives have a purine preference 
  t<-round(nrow(c)*0.1) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  #assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/top10%/", sample_names[i], "_as3B.rds"))#save the table created for this sample
}

```

for bottom 1%
```{r}
#first for 3a
#this is how to get the bottom 1% (must do same for 10% similarly)
for(i in 1:3){
  c<-readRDS(file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference so we put 
  #most positive will be rank1 
  #negatives have a pyrimidine preference 
  #positives purine preference
  t<-round(nrow(c)*0.1) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/bottom10%/", sample_names[i], ".rds"))#save the table created for this sample
}

#same for 3B
for(i in 4:6){
  c<-readRDS(file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(avg_meth>0)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference 
  #most megative will be rank1 
  #negatives have a purine preference 
  #positives purine pref
  t<-round(nrow(c)*0.1) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/bottom10%/", sample_names[i], ".rds"))#save the table created for this sample
}

#now same for WT, once treated as 3A and once as 3B
#as 3a
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(-c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference
  #most negative will be rank1 
  #negatives have a pyrimidine preference 
  t<-round(nrow(c)*0.01) # find n for top 1 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 1%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/bottom1%/", sample_names[i], "_as3A.rds"))#save the table created for this sample
}

#same for as 3B
for(i in 7:8){
  c<-readRDS(file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/", sample_names[i], ".RDS"))
  #We are going to filter out the bins that contain less than 3 mapped CG 
  #We are going to filter out the bins that contain less than 5 mapped CG 
  c<-c %>% filter(CG_num>4)
  c<-c %>% filter(!is.na(Purine_num) & !is.na(Pyrimidine_num)) #have at least one from both
  c<- c %>% filter(Purine_num>1 & Pyrimidine_num>1)
  #now create columns with modified methylation
  c<-c %>% mutate(Purine_meth_mod = Purine_meth + 0.01)
  c<-c %>% mutate(Pyrimidine_meth_mod = Pyrimidine_meth + 0.01)
  #now create col with ratio of those two
  c <-c %>% mutate(ratio_pur_pyr = Purine_meth_mod / Pyrimidine_meth_mod)
  #now create col of log2 of that ratio 
  options(scipen = 999)# to avoid scientific notation
  c<-c %>% mutate(ratio_purpyr_log = log2(ratio_pur_pyr)) 
  c$rank<-rank(c$ratio_purpyr_log)#Rank references the position of the value in the sorted vector and is in the same order as the original sequence 
  ###NOTE we now want the opposite preference
  #most positivw will be rank1 
  #negatives have a purine preference 
  t<-round(nrow(c)*0.01) # find n for top 10 %
  d<-c %>% arrange(rank) #rearrange df to have lowest rank (ie biggest difference on top)
  max_rank<-d[t,]$rank #extract the rank at the position of 10%
  #we want to keep everything up to that rank 
  e<- d %>% filter(rank<=max_rank)
  #assign(sample_names[i], e)
  saveRDS(e,file=paste0("../data/processed/bins_with_strand_information/CpGs/1kb/bottom1%/", sample_names[i], "_as3B.rds"))#save the table created for this sample
}
```